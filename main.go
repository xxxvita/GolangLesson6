package main

import "fmt"

func main() {
	var i *int = new(int)
	var p int

	// На сколько я понимаю из теории программирования (давно это было)
	// для распарсивания выражения применяется польская нотация (PN), которая представляет из себя
	// сосредоточение всех операторов (такие как математические знаки, приведение типов)
	// слева от операндов (слева направо) с учётом их веса (порядка выполнения)), а все операнды потом.
	// Это раз.
	// Два. компилятор точно знает сколько между операндами стоит знаков.

	// Три. В языке Go есть требование (я не чётко знаю правило, но и не подсматриваю), чтобы
	// операнды были одного типа или левый должен приводиться к правому (так кажется).
	// Так вот:
	// Если на каждой итерации взятия знака слева(выбираются столько операндов справа,
	// сколько требуется для оператора), для выражения достаточно и всё корректно, то оно вычисляется,
	// операнд уничтожается, результат вычисления становится операндом для следующей итерации.const

	d := p*i + 5
	// В примере: *+; p, i 5
	// берётся умножение: требуется два операнда, берётся p и i, но умножение между int
	// и *int невозможно (более никаких операторов между ними нет) -- получается ошибка.

	d := p**i + 5
	// В примере: **; p i
	// что при строгой типизации Go compiler понимает, то что взяв сначала умножение и p, и i,
	// увидев, что типы не совпадают, ищет ещё оператор (может приведение типа), видит
	// ещё звезду, берёт её (проверяет; да - это разыменовывание указателя на int приведёт
	// к валидной операции умножения int и int), выполняет

	d := p * **i // В примере: ***; p i всё тоже самое, что и в примере выше, но компилятор получит ситуацию,
	// в которой после разыменовывания *int провести операцию не удаётся, т.к. есть ещё звезда,
	// а она лишняя - разыменовывать значение в ячейке не надо, т.к. мы знаем, что там int.

	// Как-то так.
	fmt.Printf("%v, %d", *i, d)
}
